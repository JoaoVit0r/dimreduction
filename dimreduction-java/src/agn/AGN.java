/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package agn;

import java.io.Serializable;
import java.util.Random;
import java.util.Vector;

/**
 * Represents an Artificial Gene Network model for simulating gene expression patterns.
 * 
 * <p>
 * This class implements a computational model of gene regulatory networks that can
 * generate and analyze artificial time series data resembling gene expression profiles.
 * The model supports various network topologies, connection densities, and regulatory
 * functions to simulate different biological network behaviors.
 * </p>
 * 
 * <p>
 * The AGN processing workflow consists of:
 * <ol>
 *   <li>Network initialization with specific topology and parameters</li>
 *   <li>Gene state initialization with random or predefined values</li>
 *   <li>Time series generation through state transitions</li>
 *   <li>Signal normalization and quantization</li>
 *   <li>Statistical analysis of generated signals</li>
 * </ol>
 * </p>
 *
 * @see Gene
 * @see java.io.Serializable
 */
public class AGN implements Serializable {
    // Network configuration parameters
    /**
     * Type of network topology (e.g., "random", "scale-free", "small-world").
     * Defines how genes are interconnected in the network structure.
     */
    private String topology = null;
    
    /**
     * Number of genes in the network.
     * Determines the network size and dimensionality of the generated signals.
     */
    private int nrgenes;
    
    /**
     * Size of the temporal signal that will be generated.
     * Represents the number of time points in the expression profiles.
     */
    private int signalsize;
    
    /**
     * Number of initializations (concatenations) for temporal signal generation.
     * Controls how many different initial conditions are used to create the complete signal.
     */
    private int nrinitializations;
    
    /**
     * Quantization level assumed by genes in the network.
     * Defines how many discrete values each gene can take (e.g., 2 for binary).
     */
    private int quantization;
    
    /**
     * Average number of edges (connections) per gene in the network.
     * Controls network density and complexity of interactions.
     */
    private float avgedges;
    
    /**
     * Determines whether all possible Boolean functions will be used.
     * When true, uses all 2^2^k possible Boolean functions; when false, uses only a
     * reduced set of 10 biologically meaningful Boolean functions.
     */
    private boolean allbooleanfunctions;
    
    // Network components
    /**
     * Array containing all genes in the network.
     * Each gene has its own state, connections, and regulatory function.
     */
    private Gene[] genes;
    
    // Signal data structures
    /**
     * Raw temporal expression signal generated by the network.
     * Stores the expression values for all genes across all time points.
     */
    private float[][] temporalsignal;
    
    /**
     * Normalized version of the temporal expression signal.
     * Values are standardized for each time point based on statistical properties.
     */
    private float[][] temporalsignalnormalized;
    
    /**
     * Quantized version of the temporal expression signal.
     * Expression values are discretized into specified number of levels.
     */
    private int[][] temporalsignalquantized;
    
    /**
     * Labels associated with the temporal signal data points.
     * Can be used for classification or clustering of time points.
     */
    private Vector labelstemporalsignal;
    
    // Statistical analysis data
    /**
     * Mean expression value for each time point (column).
     * Used for normalization and statistical analysis.
     */
    private float [] mean;
    
    /**
     * Standard deviation of expression values for each time point.
     * Used for normalization and detecting variability.
     */
    private float [] std;
    
    /**
     * Lower threshold for each time point based on statistical properties.
     * Used for filtering and discretization of expression values.
     */
    private float [] lowthreshold;
    
    /**
     * Higher threshold for each time point based on statistical properties.
     * Used for filtering and discretization of expression values.
     */
    private float [] hithreshold;
    
    /**
     * Collection of genes removed by filtering operations.
     * Tracks which genes were excluded from analysis due to quality or other criteria.
     */
    private Vector removedgenes;

    //metodo construtor de uma AGN
    /**
     * Creates a fully configured Artificial Gene Network with specified topology and parameters.
     * 
     * <p>
     * Initializes a new gene network with the given configuration parameters and creates
     * an array of genes with random initial states. Each gene is assigned a unique identifier
     * and initialized with a random value between 0 and quantization-1.
     * </p>
     * 
     * @param topology The network connection topology (e.g., "random", "scale-free").
     * @param nrgenes The number of genes in the network.
     * @param signalsize The length of the temporal signal to be generated.
     * @param nrinitializations Number of different initial conditions for signal generation.
     * @param quantization The number of discrete levels each gene can take.
     * @param avgedges The average number of connections per gene.
     * @param allbooleanfunctions Whether to use the complete set of Boolean functions or only biologically meaningful ones.
     * 
     * @see Gene
     */
    public AGN(String topology, int nrgenes, int signalsize, int nrinitializations,
            int quantization, float avgedges, boolean allbooleanfunctions) {
        this.topology = topology;
        this.nrgenes = nrgenes;
        this.signalsize = signalsize;
        this.nrinitializations = nrinitializations;
        this.quantization = quantization;
        this.avgedges = avgedges;
        this.allbooleanfunctions = allbooleanfunctions;
        genes = new Gene[nrgenes];
        Random rn = new Random(System.nanoTime());
        for (int i = 0; i < nrgenes; i++) {
            genes[i] = new Gene();
            genes[i].setName("g"+i);
            genes[i].setProbsetname("g"+i);
            genes[i].setDescription("g"+i);
            genes[i].setIndex(i);
            genes[i].setValue(rn.nextInt(quantization));
        }
    }

    /**
     * Creates a simplified Artificial Gene Network with minimal configuration parameters.
     * 
     * <p>
     * Initializes a new gene network with only essential parameters: network size, signal length,
     * and quantization level. This constructor omits topology settings, edge configuration,
     * and Boolean function selection, using default values where necessary.
     * Each gene is initialized with a random value between 0 and quantization-1.
     * </p>
     * 
     * @param nrgenes The number of genes in the network.
     * @param signalsize The length of the temporal signal to be generated.
     * @param quantization The number of discrete levels each gene can take.
     * 
     * @see #AGN(String, int, int, int, int, float, boolean) The complete constructor with all parameters.
     */
    public AGN(int nrgenes, int signalsize, int quantization) {
        this.nrgenes = nrgenes;
        this.signalsize = signalsize;
        this.quantization = quantization;
        genes = new Gene[nrgenes];
        Random rn = new Random(System.nanoTime());
        for (int i = 0; i < nrgenes; i++) {
            genes[i] = new Gene();
            genes[i].setName("g"+i);
            genes[i].setProbsetname("g"+i);
            genes[i].setDescription("g"+i);
            genes[i].setIndex(i);
            genes[i].setValue(rn.nextInt(quantization));
        }
    }

    /**
     * Retrieves the current state values of all genes in the network.
     * 
     * <p>
     * Creates and returns a float array containing the current expression values
     * of each gene in the network. This is useful for saving the network state
     * or initializing a new network with the same gene expression pattern.
     * </p>
     * 
     * @return A float array containing the current expression values of all genes,
     *         where the index of each value corresponds to the gene index.
     * 
     * @see #setInitialValues(float[]) The complementary method to set gene values.
     * @see Gene#getValue() The method used to retrieve individual gene values.
     */
    public float[] getInitialValues() {
        float[] initialvalues = new float[nrgenes];
        for (int i = 0; i < nrgenes; i++) {
            initialvalues[i] = getGenes()[i].getValue();
        }
        return (initialvalues);
    }

    /**
     * Sets the expression values for all genes in the network.
     * 
     * <p>
     * Updates the value of each gene in the network with the provided array of expression values.
     * This method is useful for restoring a previously saved network state or initializing
     * the network with specific expression values rather than random ones.
     * </p>
     * 
     * @param initialvalues A float array containing the expression values to assign to each gene.
     *                      The array length must match the number of genes in the network.
     * 
     * @throws ArrayIndexOutOfBoundsException If the initialvalues array length does not match the number of genes.
     * 
     * @see #getInitialValues() The complementary method to retrieve gene values.
     * @see Gene#setValue(float) The method used to set individual gene values.
     */
    public void setInitialValues(float[] initialvalues) {
        for (int i = 0; i < nrgenes; i++) {
            getGenes()[i].setValue(initialvalues[i]);
        }
    }

    /**
     * @return the topology
     */
    public String getTopology() {
        return topology;
    }

    /**
     * @param topology the topology to set
     */
    public void setTopology(String topology) {
        this.topology = topology;
    }

    /**
     * @return the nrgenes
     */
    public int getNrgenes() {
        return nrgenes;
    }

    /**
     * @param nrgenes the nrgenes to set
     */
    public void setNrgenes(int nrgenes) {
        this.nrgenes = nrgenes;
    }

    /**
     * @return the signalsize
     */
    public int getSignalsize() {
        return signalsize;
    }

    /**
     * @param signalsize the signalsize to set
     */
    public void setSignalsize(int signalsize) {
        this.signalsize = signalsize;
    }

    /**
     * @return the quantization
     */
    public int getQuantization() {
        return quantization;
    }

    /**
     * @param quantization the quantization to set
     */
    public void setQuantization(int quantization) {
        this.quantization = quantization;
    }

    /**
     * @return the avgedges
     */
    public float getAvgedges() {
        return avgedges;
    }

    /**
     * @param avgedges the avgedges to set
     */
    public void setAvgedges(float avgedges) {
        this.avgedges = avgedges;
    }

    /**
     * @return the allbooleanfunctions
     */
    public boolean isAllbooleanfunctions() {
        return allbooleanfunctions;
    }

    /**
     * @param allbooleanfunctions the allbooleanfunctions to set
     */
    public void setAllbooleanfunctions(boolean allbooleanfunctions) {
        this.allbooleanfunctions = allbooleanfunctions;
    }

    /**
     * @return the nrinitializations
     */
    public int getNrinitializations() {
        return nrinitializations;
    }

    /**
     * @param nrinitializations the nrinitializations to set
     */
    public void setNrinitializations(int nrinitializations) {
        this.nrinitializations = nrinitializations;
    }

    /**
     * @return the labelstemporalsignal
     */
    public Vector getLabelstemporalsignal() {
        return labelstemporalsignal;
    }

    /**
     * @param labelstemporalsignal the labelstemporalsignal to set
     */
    public void setLabelstemporalsignal(Vector labelstemporalsignal) {
        this.labelstemporalsignal = labelstemporalsignal;
    }

    /**
     * @return the genes
     */
    public Gene[] getGenes() {
        return genes;
    }

    /**
     * @param genes the genes to set
     */
    public void setGenes(Gene[] genes) {
        this.genes = genes;
    }

    /**
     * @return the temporalsignal
     */
    public float[][] getTemporalsignal() {
        return temporalsignal;
    }

    /**
     * @param temporalsignal the temporalsignal to set
     */
    public void setTemporalsignal(float[][] temporalsignal) {
        this.temporalsignal = temporalsignal;
    }

    /**
     * Sets both the temporal signal data and its associated labels in a single operation.
     * 
     * <p>
     * This convenience method updates both the raw temporal expression data and its 
     * corresponding classification labels simultaneously. It is useful when importing
     * complete datasets that include both expression profiles and their categorizations.
     * </p>
     * 
     * @param temporalsignal A 2D array of expression values where rows represent genes and
     *                       columns represent time points or conditions.
     * @param labels A Vector of labels corresponding to each column (time point) in the signal.
     * 
     * @see #setTemporalsignal(float[][]) The method for setting only the signal data.
     * @see #setLabelstemporalsignal(Vector) The method for setting only the labels.
     */
    public void setTemporalSignal(float[][] temporalsignal, Vector labels) {
        this.setTemporalsignal(temporalsignal);
        this.setLabelstemporalsignal(labels);
    }

    /**
     * @return the mean
     */
    public float[] getMean() {
        return mean;
    }

    /**
     * @param mean the mean to set
     */
    public void setMean(float[] mean) {
        this.mean = mean;
    }

    /**
     * @return the std
     */
    public float[] getStd() {
        return std;
    }

    /**
     * @param std the std to set
     */
    public void setStd(float[] std) {
        this.std = std;
    }

    /**
     * @return the removedgenes
     */
    public Vector getRemovedgenes() {
        return removedgenes;
    }

    /**
     * @param removedgenes the removedgenes to set
     */
    public void setRemovedgenes(Vector removedgenes) {
        this.removedgenes = removedgenes;
    }

    /**
     * @return the lowthreshold
     */
    public float[] getLowthreshold() {
        return lowthreshold;
    }

    /**
     * @param lowthreshold the lowthreshold to set
     */
    public void setLowthreshold(float[] lowthreshold) {
        this.lowthreshold = lowthreshold;
    }

    /**
     * @return the hithreshold
     */
    public float[] getHithreshold() {
        return hithreshold;
    }

    /**
     * @param hithreshold the hithreshold to set
     */
    public void setHithreshold(float[] hithreshold) {
        this.hithreshold = hithreshold;
    }

    /**
     * @return the temporalsignalnormalized
     */
    public float[][] getTemporalsignalnormalized() {
        return temporalsignalnormalized;
    }

    /**
     * @param temporalsignalnormalized the temporalsignalnormalized to set
     */
    public void setTemporalsignalnormalized(float[][] temporalsignalnormalized) {
        this.temporalsignalnormalized = temporalsignalnormalized;
    }

    /**
     * @return the temporalsignalquantized
     */
    public int[][] getTemporalsignalquantized() {
        return temporalsignalquantized;
    }

    /**
     * @param temporalsignalquantized the temporalsignalquantized to set
     */
    public void setTemporalsignalquantized(int[][] temporalsignalquantized) {
        this.temporalsignalquantized = temporalsignalquantized;
    }

    /**
     * Converts a float matrix to a quantized integer matrix for discrete analysis.
     * 
     * <p>
     * This method creates an integer matrix by casting each float value in the input matrix
     * to an integer through truncation. The resulting matrix can be used for discrete
     * data analysis methods that require integer expression levels.
     * </p>
     * 
     * <p>
     * Note that this direct casting approach differs from formal quantization that uses
     * thresholds and binning. It simply truncates decimal values without rounding.
     * </p>
     * 
     * @param temporalsignalquantized A 2D float array containing expression values to be converted.
     * 
     * @see #getTemporalsignalquantized() The method to retrieve the quantized signal.
     * @see #setTemporalsignalquantized(int[][]) The alternate method for directly setting integer values.
     */
    public void setTemporalsignalquantized(float[][] temporalsignalquantized) {
        this.temporalsignalquantized = new int[temporalsignalquantized.length][temporalsignalquantized[0].length];
        for (int i = 0; i < temporalsignalquantized.length; i++){
            for (int j = 0; j < temporalsignalquantized[0].length; j++){
                this.temporalsignalquantized[i][j] = (int) temporalsignalquantized[i][j];
            }
        }
    }

}
